import io
import os
import json
import yaml
import shutil
import subprocess
import pkg_resources

import click

from rtk8s.rendering import render_project, render_string
from rtk8s.objects import Secret, Ingress

TEMPLATES_ROOT = pkg_resources.resource_filename("rtk8s", "templates")

V1_ROOT = os.path.join(TEMPLATES_ROOT, "v1")

RTK_SVC_TEMPLATE = os.path.join(V1_ROOT, "service/")
RTK_CONF_TEMPLATE = os.path.join(V1_ROOT, "spec/config.yml")


def _cmd(s):
    print(s)


def _update(deployment, target, prefix):
    path = os.path.join(prefix, target)

    paths = []
    for root, dirs, files in os.walk(os.path.join(path, "registry")):
        for file in files:
            if file.endswith(".json"):
                subpath = file.replace(".json", "")
                paths.append(subpath)

    ingress = Ingress(deployment, paths=paths)

    with open(os.path.join(path, "manifests", "ingress.json"), "w") as ingress_spec:
        ingress_spec.write(ingress.to_json(indent=4))


@click.group()
def cli():
    pass


@cli.command()
@click.argument("target")
@click.option("-p", "--prefix", default=".rtk8s_apps/v1/")
@click.option("-c", "--confirm", default=True)
def delete(target, prefix, confirm):
    root = os.path.join(prefix, target)
    if not os.path.exists(root):
        raise FileNotFoundError(f"Cannot find an initialised rtk8s deployment at {root}.")

    elif confirm and input(f"Are you sure you want to delete the deployment at {root}? Y/n") == "Y":

        print("Deleting apps...")
        for app in os.listdir(os.path.join(root, "registry")):
            name = os.path.splitext(app)[0]
            print(f"Deleting '{name}'...")
            for file in os.listdir(os.path.join(root, "src", name, "app", "manifests")):
                _cmd(f"kubectl delete -f {file}")

            for file in os.listdir(os.path.join(root, "src", name, "proxy", "manifests")):
                _cmd(f"kubectl delete -f {file}")

        print("Deleting ingress...")
        for file in os.listdir(os.path.join(root, "manifests")):
            _cmd(f"kubectl delete -f {file}")
        print("Cleaning directories...")
        shutil.rmtree(root)
        print("Done.")


@cli.command()
@click.argument("deployment")
@click.option("-t", "--target", default="default")
@click.option("-p", "--prefix", default=".rtk8s_apps/v1/")
@click.option("-k", "--ssl-keys", required=True)
def create(deployment, ssl_keys, target, prefix):
    path = os.path.join(prefix, target)
    if os.path.exists(path):
        print(f"There's an existing deployment at {path}. Skipping.")
    else:
        os.makedirs(os.path.join(path, "manifests"))

        secret = Secret(deployment,
                        key=os.path.join(ssl_keys, "key.pem"),
                        crt=os.path.join(ssl_keys, "cert.pem")
                        )

        with open(os.path.join(path, "manifests", "secret.json"), "w") as secret_spec:
            secret_spec.write(secret.to_json(indent=4))

        ingress = Ingress(deployment)

        with open(os.path.join(path, "manifests", "ingress.json"), "w") as ingress_spec:
            ingress_spec.write(ingress.to_json(indent=4))


@cli.command()
@click.argument("name")
@click.argument("deployment")
@click.option("-p", "--prefix", default=".rtk8s_apps/v1/")
@click.option("-t", "--target", default="default")
@click.option("-c", "--config", default=None)
@click.option("-T", "--template", default=RTK_CONF_TEMPLATE)
def add(name, deployment, prefix, target, config, template):

    splunk_info = {"username": os.getenv("SPLUNK_USERNAME", ""),
                   "password": os.getenv("SPLUNK_USERNAME", ""),
                   "host": os.getenv("SPLUNK_HOST", ""),
                   "port": os.getenv("SPLUNK_PORT", "")}

    if not config:
        app_info = {"host": os.getenv("SMEILING_HOST", ""), "name": name}
        data = render_string(open(template).read(), {"app": app_info, "splunk": splunk_info})
        config = yaml.load(io.StringIO(data), yaml.SafeLoader)
    elif config.endswith(".json"):
        config = json.load(open(config))
    elif config.endswith(".yml") or config.endswith(".yaml"):
        config = yaml.load(open(config), yaml.SafeLoader)

    registry = os.path.join(prefix, target, "registry")

    if not os.path.exists(registry):
        os.makedirs(registry)

    config_path = os.path.join(registry, f"{name}.json")

    if os.path.exists(config_path):
        raise FileExistsError(f"An app with name '{name}' already exists.")
    else:
        with open(config_path, "w") as config_file:
            config_file.write(json.dumps(config, indent=4))

        _update(deployment, target, prefix)


@cli.command()
@click.argument("name")
@click.argument("deployment")
@click.option("-p", "--prefix", default=".rtk8s_apps/v1/")
@click.option("-t", "--target", default="default")
@click.option("-T", "--templates", default=RTK_SVC_TEMPLATE)
def deploy(name, deployment, target, prefix, templates):
    root = os.path.join(prefix, target)
    conf_path = os.path.join(root, "registry", name+".json")

    print(f"Building {name} for {deployment}...")
    if not os.path.exists(root):
        raise FileNotFoundError(f"Cannot find an initialised rtk8s deployment at {root}.")
    elif not os.path.exists(conf_path):
        raise FileNotFoundError(f"Cannot find a valid config for {name} at {conf_path}.")
    else:
        with open(conf_path) as conf_file:
            config = json.load(conf_file)

            name = config["app"]["name"]

            src_path = os.path.join(prefix, target, "src", name)

            render_project(templates, src_path, config)

            for root, dirs, files in os.walk(src_path):
                component = os.path.split(root)[-1]
                for file in files:
                    if file == "Dockerfile":
                        _cmd(f"docker build {src_path} -t {name}-{component}:latest -f Dockerfile")

                        repo_host = config["app"].get("deployment", {}).get("repo", "localhost:32000")
                        if repo_host.startswith("localhost"):
                            """
                            docker build . -t ${dir%/}:latest -f ${dir%/}/Dockerfile
                            docker tag ${dir%/} gcr.io/encoded-antler-258511/${dir%/}
                            docker push gcr.io/encoded-antler-258511/${dir%/}
                            """
                            _cmd(f"docker tag {name}-{component} {repo_host}/{name}-{component}")
                            _cmd(f"docker push {repo_host}/{name}-{component}")

            for root, dirs, files in os.walk(os.path.join(src_path, "manifests")):
                for file in files:
                    _cmd(f"kubectl apply -f {file}")

    print(f"Built {name} for {deployment}. Your service will be available shortly at '/{name}-app'")


@cli.command()
@click.argument("name")
@click.argument("deployment")
@click.option("-p", "--prefix", default=".rtk8s_apps/v1/")
@click.option("-t", "--target", default="default")
def remove(name, deployment, target, prefix):
    root = os.path.join(prefix, target)
    conf_path = os.path.join(root, "registry", name + ".json")
    src_path = os.path.join(root, "src", name)

    if not os.path.exists(root):
        raise FileNotFoundError(f"Cannot find an initialised rtk8s deployment at {root}.")
    elif not os.path.exists(conf_path):
        raise FileNotFoundError(f"Cannot remove app '{name}' - it does not exist (no file at {conf_path}.")
    elif not os.path.join(src_path):
        raise FileNotFoundError(f"Malformed app initialisation detected. "
                                f"Got a valid registry file, but no src at {src_path}. Aborting.")
    else:

        for root, dirs, files in os.walk(os.path.join(src_path, "manifests")):
            for file in files:
                _cmd(f"kubectl delete -f {file}")

        os.unlink(conf_path)
        shutil.rmtree(src_path)

        _update(deployment, target, prefix)


if __name__ == "__main__":
    cli()
